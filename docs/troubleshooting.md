# Known Issues & Troubleshooting

This document tracks the main errors encountered while setting up and running the Quantum Embedding Benchmark, along with their solutions.

## 1. Sub-repository Dependency Conflicts (Python 3.12+)
**Error:** 
`ImportError: cannot import name 'gcd' from 'fractions' (/opt/anaconda3/envs/minor312/lib/python3.12/fractions.py)`

**Cause:** 
The cloned repository for `oct_based` contained a `requirements.txt` file that strictly pinned an ancient version of NetworkX (`networkx==1.11`). When `pip` installed it, it downgraded the entire environment's NetworkX library. Version 1.11 relies on standard Python packages (like `fractions.gcd`) that were removed in Python 3.9+.

**Solution:**
Never use strict `==` legacy pins if using a modern Python environment. We updated `implementations/oct_based/requirements.txt` to `networkx>=2.6.0` and reinstalled the requirements.

## 2. Minorminer Type/Iterable Errors
**Error:** 
`TypeError: 'int' object is not iterable` inside `minorminer.find_embedding`

**Cause:**
This typically occurs when passing `dict` objects (adjacency matrices) generated by NetworkX tree/grid graphs into `minorminer`. Depending on the exact Python version and the compiled C++ Cython bindings installed on your specific machine, `minorminer` may fail to correctly interpret `dict` keys as nodes, falling back to assuming it was handed a list of physical edges, and then failing to iterate over an integer.

**Solution:**
Always pass explicit edge lists (`list(G.edges())`) parameters directly into `minorminer.find_embedding` rather than relying on its internal dictionary-guessing parser.

## 3. Python Version Discrepancies
**Requirement:** 
It is highly recommended to use **Python 3.12** in a dedicated Conda environment.

**Cause:**
Jumping between major Python versions (like from 3.10 to 3.12) within the same environment breaks pre-compiled C++ binaries (which `numpy`, `scipy`, and `minorminer` heavily rely upon). Furthermore, different Python versions resolve `pip` dependency sub-trees differently.

**Solution:**
Always use a dedicated environment: `conda create -n minor312 python=3.12`. All requirements must be installed fresh inside that environment using `python -m pip install -r requirements.txt`.

## 4. Subprocess Integration Issues

### 4a. Absolute vs Relative Paths
**Error:** `[Errno 2] No such file or directory`  
**Cause:** `subprocess.run(..., cwd=...)` changes the working directory *before* resolving the executable path, so relative paths resolve incorrectly.  
**Fix:** Always use `str(exe_path.resolve())` for absolute paths.

### 4b. ATOM Input Format & Arguments
**Error:** Segmentation fault (exit code -11)  
**Cause:** ATOM's `read_program()` in `io.cpp` expects `-pfile` flag, and the input file must be formatted as: line 1 = N (node count), lines 2..N+1 = node indices (one per line), remaining lines = edges (`u v`). The notebook uses `./main -pfile <file> -test <num>`. Passing wrong positional args or wrong file format causes a segfault.  
**Fix:** Use `[str(atom_exe), '-pfile', source_file, '-test', '0']` and write the graph file with one node index per line before the edge list.

### 4c. OCT-Based Output File Location
**Error:** `.embedding` output file not found after successful run  
**Cause:** OCT-Based's driver writes `<outfile>.embedding` and `<outfile>.timing` relative to its working directory. If the `-o` flag points to `/var/folders/.../tmp.txt`, the output files are created there but may not be found if paths are mishandled. Additionally, OCT requires Chimera topology flags (`-c`, `-m`, `-n`) instead of a target graph file.  
**Fix:** Write all temp files inside `oct_dir` using `tempfile.NamedTemporaryFile(dir=oct_dir)`, and pass `-c 4 -m 4 -n 4` instead of `-hfile`.

### 4d. CHARME Architecture
**Error:** `[Errno 8] Exec format error`  
**Cause:** CHARME is a Python RL framework (PyTorch-based), not a standalone C++ executable. Its internal C++ components (`atom_system`) are called by `charme/env.py` via `os.system()`. It cannot be invoked as a subprocess.  
**Fix:** Import CHARME's Python modules directly rather than calling it via subprocess.




